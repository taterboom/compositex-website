[{"id":"c79cb1ee-d950-43e2-b501-38a00f986f84","nodes":[{"id":"058e27dc-82cb-482b-8d09-e6e52b08ca2b","metaId":"mainWorld","name":"MainWorld","options":{"expression":"document.querySelector(\".assetPreview img\").src"},"metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"MainWorld\",\n      desc: \"Get main world info\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"expression\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context.mainWorld(input || options.expression)\n    },\n  }\n  return nodeConfig\n})()","id":"mainWorld","config":{"name":"MainWorld","desc":"Get main world info","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"expression","type":"string"}]}}},{"id":"d4f2c532-e3fa-44a7-8883-5de90ed86143","metaId":"aab0b58a-fe73-4325-aa73-40c605e12247","name":"ZeplinImg","metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ZeplinImg\",\n      desc: \"Get Zeplin a desired img url by input img url\",\n      input: { type: \"string\" },\n      output: { type: \"string\" },\n      options: [\n        { name: \"format\", type: \"string\", default: \"png\" },\n        { name: \"densityScale\", type: \"number\", default: 3 },\n      ],\n    },\n    run(input, options, context) {\n      return (async function (existUrl, format, densityScale) {\n        const apiPrefix = \"https://api.zeplin.io/v2\"\n        const mainWorldCookie = await context.mainWorld(\"document.cookie\")\n        const token = mainWorldCookie.split(\";\").find(item => item.trim().startsWith('userToken=')).split('userToken=')[1]\n        const mainWorldPath = await context.mainWorld(\"location.pathname\")\n        const path = mainWorldPath.replace(\"project\", \"projects\").replace(\"screen\", \"screens\")\n        const versionsRes = await context.fetch(`${apiPrefix}${path}/versions`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const versionId = versionsRes.versions[0]._id\n        const assetsUrlRes = await context.fetch(`${apiPrefix}${path}/versions/${versionId}/assets`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const asstesUrl = assetsUrlRes.url\n        // TODO cache layers\n        const layers = await context.fetch(asstesUrl).then(res => res.data)\n        const layer = layers.find(item => item.contents.some(content => content.url === existUrl))\n        return layer?.contents.find(item => item.format === format && item.densityScale === densityScale)\n      })(input, options.format, options.densityScale)\n    }\n  }\n  return nodeConfig\n})()","id":"aab0b58a-fe73-4325-aa73-40c605e12247","config":{"name":"ZeplinImg","desc":"Get Zeplin a desired img url by input img url","input":{"type":"string"},"output":{"type":"string"},"options":[{"name":"format","type":"string","default":"png"},{"name":"densityScale","type":"number","default":3}]}}},{"id":"810264b3-f164-4d32-a9c9-d236e06b58f6","metaId":"lodashGet","name":"LodashGet","options":{"path":"url"},"metaNode":{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}}}],"name":"GetZeplinImg","desc":""},{"id":"1818b832-8d8b-4fba-ab9b-4d9f50f5411f","nodes":[{"id":"058e27dc-82cb-482b-8d09-e6e52b08ca2b","metaId":"mainWorld","name":"MainWorld","options":{"expression":"document.querySelector(\".assetPreview img\").src"},"metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"MainWorld\",\n      desc: \"Get main world info\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"expression\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context.mainWorld(input || options.expression)\n    },\n  }\n  return nodeConfig\n})()","id":"mainWorld","config":{"name":"MainWorld","desc":"Get main world info","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"expression","type":"string"}]}}},{"id":"d4f2c532-e3fa-44a7-8883-5de90ed86143","metaId":"aab0b58a-fe73-4325-aa73-40c605e12247","name":"ZeplinImg","metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ZeplinImg\",\n      desc: \"Get Zeplin a desired img url by input img url\",\n      input: { type: \"string\" },\n      output: { type: \"string\" },\n      options: [\n        { name: \"format\", type: \"string\", default: \"png\" },\n        { name: \"densityScale\", type: \"number\", default: 3 },\n      ],\n    },\n    run(input, options, context) {\n      return (async function (existUrl, format, densityScale) {\n        const apiPrefix = \"https://api.zeplin.io/v2\"\n        const mainWorldCookie = await context.mainWorld(\"document.cookie\")\n        const token = mainWorldCookie.split(\";\").find(item => item.trim().startsWith('userToken=')).split('userToken=')[1]\n        const mainWorldPath = await context.mainWorld(\"location.pathname\")\n        const path = mainWorldPath.replace(\"project\", \"projects\").replace(\"screen\", \"screens\")\n        const versionsRes = await context.fetch(`${apiPrefix}${path}/versions`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const versionId = versionsRes.versions[0]._id\n        const assetsUrlRes = await context.fetch(`${apiPrefix}${path}/versions/${versionId}/assets`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const asstesUrl = assetsUrlRes.url\n        // TODO cache layers\n        const layers = await context.fetch(asstesUrl).then(res => res.data)\n        const layer = layers.find(item => item.contents.some(content => content.url === existUrl))\n        return layer?.contents.find(item => item.format === format && item.densityScale === densityScale)\n      })(input, options.format, options.densityScale)\n    }\n  }\n  return nodeConfig\n})()","id":"aab0b58a-fe73-4325-aa73-40c605e12247","config":{"name":"ZeplinImg","desc":"Get Zeplin a desired img url by input img url","input":{"type":"string"},"output":{"type":"string"},"options":[{"name":"format","type":"string","default":"png"},{"name":"densityScale","type":"number","default":3}]}}},{"id":"810264b3-f164-4d32-a9c9-d236e06b58f6","metaId":"lodashGet","name":"LodashGet","options":{"path":"url"},"metaNode":{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}}},{"id":"00b56d47-4ae5-4263-8658-cd2870c715a1","metaId":"208e1a56-a01d-4ab4-874c-e9226d617695","name":"Tinypng","options":{"apiKey":"PZB818tH4zLbrptt8dMgR5Hn0LZ4n7Ms"},"metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"Tinypng\",\n      desc: \"Compress via Tinypng\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"apiKey\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context\n        .fetch(\"https://api.tinify.com/shrink\", {\n          method: \"POST\",\n          headers: {\n            Authorization: `Basic ${window.btoa(`api:${options.apiKey}`)}`,\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            source: {\n              url: input,\n            },\n          }),\n        })\n        .then((res) => res.data)\n    },\n  }\n  return nodeConfig\n})()","id":"208e1a56-a01d-4ab4-874c-e9226d617695","config":{"name":"Tinypng","desc":"Compress via Tinypng","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"apiKey","type":"string"}]}}},{"id":"26cc8498-158d-4089-a363-a9e248f43c29","metaId":"lodashGet","name":"LodashGet","options":{"path":"output.url"},"metaNode":{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}}},{"id":"eb5ff9d6-07c6-46d5-84ca-a86b674ff385","metaId":"ShanbayOss","name":"ShanbayOss","metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ShanbayOss\",\n      desc: \"Shanbay Oss uploader\",\n      input: { type: \"string\" },\n      output: { type: \"json\" },\n      options: [{ name: \"service\", type: \"string\", default: \"cms_comment_image\" }],\n    },\n    run(input, options, context) {\n      return context\n        .fetch(input)\n        .then((res) => {\n          const immetype = res.data.type\n          let ext = immetype.split('/')[1]\n          if (ext === \"svg+xml\") {\n            ext = \"svg\"\n          }\n          console.log(ext, immetype)\n          return new File([res.data], \"compositex-shanbay-oss.\" + ext, { type: immetype })\n        })\n        .then((file) => context.ShanbayOss({ file, service: options.service }))\n    },\n  }\n  return nodeConfig\n})()","id":"ShanbayOss","config":{"name":"ShanbayOss","desc":"Shanbay Oss uploader","input":{"type":"string"},"output":{"type":"json"},"options":[{"name":"service","type":"string","default":"cms_comment_image"}]}}},{"id":"0f0c202d-7755-43f0-9c20-374dcde47bfb","metaId":"lodashGet","name":"LodashGet","options":{"path":"url"},"metaNode":{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}}}],"name":"Zeplin2Shanbay","desc":"generate shanbay oss img url from current page selected img"},{"id":"2734a2bc-293a-43f9-8b1b-53ec7961c39c","nodes":[{"id":"058e27dc-82cb-482b-8d09-e6e52b08ca2b","metaId":"mainWorld","name":"MainWorld","options":{"expression":"document.querySelector(\".assetPreview img\").src"},"metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"MainWorld\",\n      desc: \"Get main world info\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"expression\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context.mainWorld(input || options.expression)\n    },\n  }\n  return nodeConfig\n})()","id":"mainWorld","config":{"name":"MainWorld","desc":"Get main world info","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"expression","type":"string"}]}}},{"id":"d4f2c532-e3fa-44a7-8883-5de90ed86143","metaId":"aab0b58a-fe73-4325-aa73-40c605e12247","name":"ZeplinImg","metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ZeplinImg\",\n      desc: \"Get Zeplin a desired img url by input img url\",\n      input: { type: \"string\" },\n      output: { type: \"string\" },\n      options: [\n        { name: \"format\", type: \"string\", default: \"png\" },\n        { name: \"densityScale\", type: \"number\", default: 3 },\n      ],\n    },\n    run(input, options, context) {\n      return (async function (existUrl, format, densityScale) {\n        const apiPrefix = \"https://api.zeplin.io/v2\"\n        const mainWorldCookie = await context.mainWorld(\"document.cookie\")\n        const token = mainWorldCookie.split(\";\").find(item => item.trim().startsWith('userToken=')).split('userToken=')[1]\n        const mainWorldPath = await context.mainWorld(\"location.pathname\")\n        const path = mainWorldPath.replace(\"project\", \"projects\").replace(\"screen\", \"screens\")\n        const versionsRes = await context.fetch(`${apiPrefix}${path}/versions`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const versionId = versionsRes.versions[0]._id\n        const assetsUrlRes = await context.fetch(`${apiPrefix}${path}/versions/${versionId}/assets`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const asstesUrl = assetsUrlRes.url\n        // TODO cache layers\n        const layers = await context.fetch(asstesUrl).then(res => res.data)\n        const layer = layers.find(item => item.contents.some(content => content.url === existUrl))\n        return layer?.contents.find(item => item.format === format && item.densityScale === densityScale)\n      })(input, options.format, options.densityScale)\n    }\n  }\n  return nodeConfig\n})()","id":"aab0b58a-fe73-4325-aa73-40c605e12247","config":{"name":"ZeplinImg","desc":"Get Zeplin a desired img url by input img url","input":{"type":"string"},"output":{"type":"string"},"options":[{"name":"format","type":"string","default":"png"},{"name":"densityScale","type":"number","default":3}]}}},{"id":"810264b3-f164-4d32-a9c9-d236e06b58f6","metaId":"lodashGet","name":"LodashGet","options":{"path":"url"},"metaNode":{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}}},{"id":"00b56d47-4ae5-4263-8658-cd2870c715a1","metaId":"208e1a56-a01d-4ab4-874c-e9226d617695","name":"Tinypng","options":{"apiKey":"PZB818tH4zLbrptt8dMgR5Hn0LZ4n7Ms"},"metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"Tinypng\",\n      desc: \"Compress via Tinypng\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"apiKey\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context\n        .fetch(\"https://api.tinify.com/shrink\", {\n          method: \"POST\",\n          headers: {\n            Authorization: `Basic ${window.btoa(`api:${options.apiKey}`)}`,\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            source: {\n              url: input,\n            },\n          }),\n        })\n        .then((res) => res.data)\n    },\n  }\n  return nodeConfig\n})()","id":"208e1a56-a01d-4ab4-874c-e9226d617695","config":{"name":"Tinypng","desc":"Compress via Tinypng","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"apiKey","type":"string"}]}}},{"id":"26cc8498-158d-4089-a363-a9e248f43c29","metaId":"lodashGet","name":"LodashGet","options":{"path":"output.url"},"metaNode":{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}}},{"id":"eb5ff9d6-07c6-46d5-84ca-a86b674ff385","metaId":"ShanbayOss","name":"ShanbayOss","metaNode":{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ShanbayOss\",\n      desc: \"Shanbay Oss uploader\",\n      input: { type: \"string\" },\n      output: { type: \"json\" },\n      options: [{ name: \"service\", type: \"string\", default: \"cms_comment_image\" }],\n    },\n    run(input, options, context) {\n      return context\n        .fetch(input)\n        .then((res) => {\n          const immetype = res.data.type\n          let ext = immetype.split('/')[1]\n          if (ext === \"svg+xml\") {\n            ext = \"svg\"\n          }\n          console.log(ext, immetype)\n          return new File([res.data], \"compositex-shanbay-oss.\" + ext, { type: immetype })\n        })\n        .then((file) => context.ShanbayOss({ file, service: options.service }))\n    },\n  }\n  return nodeConfig\n})()","id":"ShanbayOss","config":{"name":"ShanbayOss","desc":"Shanbay Oss uploader","input":{"type":"string"},"output":{"type":"json"},"options":[{"name":"service","type":"string","default":"cms_comment_image"}]}}}],"name":"(Folk)Zeplin2Shanbay","desc":"generate shanbay oss img url from current page selected img"},{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ShanbayOss\",\n      desc: \"Shanbay Oss uploader\",\n      input: { type: \"string\" },\n      output: { type: \"json\" },\n      options: [{ name: \"service\", type: \"string\", default: \"cms_comment_image\" }],\n    },\n    run(input, options, context) {\n      return context\n        .fetch(input)\n        .then((res) => {\n          const immetype = res.data.type\n          let ext = immetype.split('/')[1]\n          if (ext === \"svg+xml\") {\n            ext = \"svg\"\n          }\n          console.log(ext, immetype)\n          return new File([res.data], \"compositex-shanbay-oss.\" + ext, { type: immetype })\n        })\n        .then((file) => context.ShanbayOss({ file, service: options.service }))\n    },\n  }\n  return nodeConfig\n})()","id":"ShanbayOss","config":{"name":"ShanbayOss","desc":"Shanbay Oss uploader","input":{"type":"string"},"output":{"type":"json"},"options":[{"name":"service","type":"string","default":"cms_comment_image"}]}},{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"MainWorld\",\n      desc: \"Get main world info\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"expression\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context.mainWorld(input || options.expression)\n    },\n  }\n  return nodeConfig\n})()","id":"mainWorld","config":{"name":"MainWorld","desc":"Get main world info","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"expression","type":"string"}]}},{"_raw":"(function () {\n        const lodashGet = (function () {\n          var FUNC_ERROR_TEXT = \"Expected a function\",\n            HASH_UNDEFINED = \"__lodash_hash_undefined__\",\n            INFINITY = 1 / 0,\n            funcTag = \"[object Function]\",\n            genTag = \"[object GeneratorFunction]\",\n            symbolTag = \"[object Symbol]\",\n            reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n            reIsPlainProp = /^\\w*$/,\n            reLeadingDot = /^\\./,\n            rePropName =\n              /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n            reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n            reEscapeChar = /\\\\(\\\\)?/g,\n            reIsHostCtor = /^\\[object .+?Constructor\\]$/,\n            freeGlobal = \"object\" == typeof global && global && global.Object === Object && global,\n            freeSelf = \"object\" == typeof self && self && self.Object === Object && self,\n            root = freeGlobal || freeSelf || Function(\"return this\")()\n          function getValue(t, e) {\n            return null == t ? void 0 : t[e]\n          }\n          function isHostObject(t) {\n            var e = !1\n            if (null != t && \"function\" != typeof t.toString)\n              try {\n                e = !!(t + \"\")\n              } catch (t) {}\n            return e\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype,\n            coreJsData = root[\"__core-js_shared__\"],\n            maskSrcKey = (function () {\n              var t = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\")\n              return t ? \"Symbol(src)_1.\" + t : \"\"\n            })(),\n            funcToString = funcProto.toString,\n            hasOwnProperty = objectProto.hasOwnProperty,\n            objectToString = objectProto.toString,\n            reIsNative = RegExp(\n              \"^\" +\n                funcToString\n                  .call(hasOwnProperty)\n                  .replace(reRegExpChar, \"\\\\$&\")\n                  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") +\n                \"$\"\n            ),\n            Symbol = root.Symbol,\n            splice = arrayProto.splice,\n            Map = getNative(root, \"Map\"),\n            nativeCreate = getNative(Object, \"create\"),\n            symbolProto = Symbol ? Symbol.prototype : void 0,\n            symbolToString = symbolProto ? symbolProto.toString : void 0\n          function Hash(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {}\n          }\n          function hashDelete(t) {\n            return this.has(t) && delete this.__data__[t]\n          }\n          function hashGet(t) {\n            var e = this.__data__\n            if (nativeCreate) {\n              var r = e[t]\n              return r === HASH_UNDEFINED ? void 0 : r\n            }\n            return hasOwnProperty.call(e, t) ? e[t] : void 0\n          }\n          function hashHas(t) {\n            var e = this.__data__\n            return nativeCreate ? void 0 !== e[t] : hasOwnProperty.call(e, t)\n          }\n          function hashSet(t, e) {\n            return (this.__data__[t] = nativeCreate && void 0 === e ? HASH_UNDEFINED : e), this\n          }\n          function ListCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = []\n          }\n          function listCacheDelete(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return !(r < 0) && (r == e.length - 1 ? e.pop() : splice.call(e, r, 1), !0)\n          }\n          function listCacheGet(t) {\n            var e = this.__data__,\n              r = assocIndexOf(e, t)\n            return r < 0 ? void 0 : e[r][1]\n          }\n          function listCacheHas(t) {\n            return -1 < assocIndexOf(this.__data__, t)\n          }\n          function listCacheSet(t, e) {\n            var r = this.__data__,\n              a = assocIndexOf(r, t)\n            return a < 0 ? r.push([t, e]) : (r[a][1] = e), this\n          }\n          function MapCache(t) {\n            var e = -1,\n              r = t ? t.length : 0\n            for (this.clear(); ++e < r; ) {\n              var a = t[e]\n              this.set(a[0], a[1])\n            }\n          }\n          function mapCacheClear() {\n            this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() }\n          }\n          function mapCacheDelete(t) {\n            return getMapData(this, t).delete(t)\n          }\n          function mapCacheGet(t) {\n            return getMapData(this, t).get(t)\n          }\n          function mapCacheHas(t) {\n            return getMapData(this, t).has(t)\n          }\n          function mapCacheSet(t, e) {\n            return getMapData(this, t).set(t, e), this\n          }\n          function assocIndexOf(t, e) {\n            for (var r = t.length; r--; ) if (eq(t[r][0], e)) return r\n            return -1\n          }\n          function baseGet(t, e) {\n            for (var r = 0, a = (e = isKey(e, t) ? [e] : castPath(e)).length; null != t && r < a; )\n              t = t[toKey(e[r++])]\n            return r && r == a ? t : void 0\n          }\n          function baseIsNative(t) {\n            return (\n              !(!isObject(t) || isMasked(t)) &&\n              (isFunction(t) || isHostObject(t) ? reIsNative : reIsHostCtor).test(toSource(t))\n            )\n          }\n          function baseToString(t) {\n            if (\"string\" == typeof t) return t\n            if (isSymbol(t)) return symbolToString ? symbolToString.call(t) : \"\"\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function castPath(t) {\n            return isArray(t) ? t : stringToPath(t)\n          }\n          function getMapData(t, e) {\n            var r = t.__data__\n            return isKeyable(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map\n          }\n          function getNative(t, e) {\n            var r = getValue(t, e)\n            return baseIsNative(r) ? r : void 0\n          }\n          function isKey(t, e) {\n            if (isArray(t)) return !1\n            var r = typeof t\n            return (\n              !(\"number\" != r && \"symbol\" != r && \"boolean\" != r && null != t && !isSymbol(t)) ||\n              reIsPlainProp.test(t) ||\n              !reIsDeepProp.test(t) ||\n              (null != e && t in Object(e))\n            )\n          }\n          function isKeyable(t) {\n            var e = typeof t\n            return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e\n              ? \"__proto__\" !== t\n              : null === t\n          }\n          function isMasked(t) {\n            return !!maskSrcKey && maskSrcKey in t\n          }\n          ;(Hash.prototype.clear = hashClear),\n            (Hash.prototype.delete = hashDelete),\n            (Hash.prototype.get = hashGet),\n            (Hash.prototype.has = hashHas),\n            (Hash.prototype.set = hashSet),\n            (ListCache.prototype.clear = listCacheClear),\n            (ListCache.prototype.delete = listCacheDelete),\n            (ListCache.prototype.get = listCacheGet),\n            (ListCache.prototype.has = listCacheHas),\n            (ListCache.prototype.set = listCacheSet),\n            (MapCache.prototype.clear = mapCacheClear),\n            (MapCache.prototype.delete = mapCacheDelete),\n            (MapCache.prototype.get = mapCacheGet),\n            (MapCache.prototype.has = mapCacheHas),\n            (MapCache.prototype.set = mapCacheSet)\n          var stringToPath = memoize(function (t) {\n            t = toString(t)\n            var o = []\n            return (\n              reLeadingDot.test(t) && o.push(\"\"),\n              t.replace(rePropName, function (t, e, r, a) {\n                o.push(r ? a.replace(reEscapeChar, \"$1\") : e || t)\n              }),\n              o\n            )\n          })\n          function toKey(t) {\n            if (\"string\" == typeof t || isSymbol(t)) return t\n            var e = t + \"\"\n            return \"0\" == e && 1 / t == -INFINITY ? \"-0\" : e\n          }\n          function toSource(t) {\n            if (null != t) {\n              try {\n                return funcToString.call(t)\n              } catch (t) {}\n              try {\n                return t + \"\"\n              } catch (t) {}\n            }\n            return \"\"\n          }\n          function memoize(o, n) {\n            if (\"function\" != typeof o || (n && \"function\" != typeof n))\n              throw new TypeError(FUNC_ERROR_TEXT)\n            var i = function () {\n              var t = arguments,\n                e = n ? n.apply(this, t) : t[0],\n                r = i.cache\n              if (r.has(e)) return r.get(e)\n              var a = o.apply(this, t)\n              return (i.cache = r.set(e, a)), a\n            }\n            return (i.cache = new (memoize.Cache || MapCache)()), i\n          }\n          function eq(t, e) {\n            return t === e || (t != t && e != e)\n          }\n          memoize.Cache = MapCache\n          var isArray = Array.isArray\n          function isFunction(t) {\n            var e = isObject(t) ? objectToString.call(t) : \"\"\n            return e == funcTag || e == genTag\n          }\n          function isObject(t) {\n            var e = typeof t\n            return !!t && (\"object\" == e || \"function\" == e)\n          }\n          function isObjectLike(t) {\n            return !!t && \"object\" == typeof t\n          }\n          function isSymbol(t) {\n            return \"symbol\" == typeof t || (isObjectLike(t) && objectToString.call(t) == symbolTag)\n          }\n          function toString(t) {\n            return null == t ? \"\" : baseToString(t)\n          }\n          function get(t, e, r) {\n            var a = null == t ? void 0 : baseGet(t, e)\n            return void 0 === a ? r : a\n          }\n          return get\n        })()\n        /** @type {CompositeX.MetaNodeConfig} */\n        const nodeConfig = {\n          config: {\n            name: \"LodashGet\",\n            desc: \"Get element from an object via lodash.get\",\n            input: { type: \"any\" },\n            output: { type: \"any\" },\n            options: [{ name: \"path\", type: \"string\" }],\n          },\n          run(input, options, context) {\n            return lodashGet(input, options.path)\n          },\n        }\n        return nodeConfig\n      })()","id":"lodashGet","config":{"name":"LodashGet","desc":"Get element from an object via lodash.get","input":{"type":"any"},"output":{"type":"any"},"options":[{"name":"path","type":"string"}]}},{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"ZeplinImg\",\n      desc: \"Get Zeplin a desired img url by input img url\",\n      input: { type: \"string\" },\n      output: { type: \"string\" },\n      options: [\n        { name: \"format\", type: \"string\", default: \"png\" },\n        { name: \"densityScale\", type: \"number\", default: 3 },\n      ],\n    },\n    run(input, options, context) {\n      return (async function (existUrl, format, densityScale) {\n        const apiPrefix = \"https://api.zeplin.io/v2\"\n        const mainWorldCookie = await context.mainWorld(\"document.cookie\")\n        const token = mainWorldCookie.split(\";\").find(item => item.trim().startsWith('userToken=')).split('userToken=')[1]\n        const mainWorldPath = await context.mainWorld(\"location.pathname\")\n        const path = mainWorldPath.replace(\"project\", \"projects\").replace(\"screen\", \"screens\")\n        const versionsRes = await context.fetch(`${apiPrefix}${path}/versions`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const versionId = versionsRes.versions[0]._id\n        const assetsUrlRes = await context.fetch(`${apiPrefix}${path}/versions/${versionId}/assets`, { headers: { \"zeplin-token\": token } }).then(res => res.data)\n        const asstesUrl = assetsUrlRes.url\n        // TODO cache layers\n        const layers = await context.fetch(asstesUrl).then(res => res.data)\n        const layer = layers.find(item => item.contents.some(content => content.url === existUrl))\n        return layer?.contents.find(item => item.format === format && item.densityScale === densityScale)\n      })(input, options.format, options.densityScale)\n    }\n  }\n  return nodeConfig\n})()","id":"aab0b58a-fe73-4325-aa73-40c605e12247","config":{"name":"ZeplinImg","desc":"Get Zeplin a desired img url by input img url","input":{"type":"string"},"output":{"type":"string"},"options":[{"name":"format","type":"string","default":"png"},{"name":"densityScale","type":"number","default":3}]}},{"_raw":"(function () {\n  /** @type {CompositeX.MetaNodeConfig} */\n  const nodeConfig = {\n    config: {\n      name: \"Tinypng\",\n      desc: \"Compress via Tinypng\",\n      input: { type: \"string\" },\n      output: { type: \"any\" },\n      options: [{ name: \"apiKey\", type: \"string\" }],\n    },\n    run(input, options, context) {\n      return context\n        .fetch(\"https://api.tinify.com/shrink\", {\n          method: \"POST\",\n          headers: {\n            Authorization: `Basic ${window.btoa(`api:${options.apiKey}`)}`,\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            source: {\n              url: input,\n            },\n          }),\n        })\n        .then((res) => res.data)\n    },\n  }\n  return nodeConfig\n})()","id":"208e1a56-a01d-4ab4-874c-e9226d617695","config":{"name":"Tinypng","desc":"Compress via Tinypng","input":{"type":"string"},"output":{"type":"any"},"options":[{"name":"apiKey","type":"string"}]}}]